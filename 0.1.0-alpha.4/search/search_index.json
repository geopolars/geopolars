{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GeoPolars","text":"<p>GeoPolars extends the Polars DataFrame library for use with geospatial data.</p>"},{"location":"#description","title":"Description","text":"<p>With heavy inspiration from <code>GeoPandas</code>, GeoPolars has two main goals:</p> <ul> <li>Faster multithreaded operations than GeoPandas while keeping an easy-to-use, high-level interface.</li> <li>Better data interoperability without copies, due to its <code>GeoArrow</code> core.</li> </ul> <p>At this point, GeoPolars is a prototype and should not be considered production-ready.</p>"},{"location":"#installation","title":"Installation","text":"<p>GeoPolars is alpha software but can be installed from PyPI:</p> <pre><code>pip install --pre geopolars\n</code></pre> <p>(<code>-pre</code> is necessary to allow installation of an alpha release). The publishing processs includes binary wheels for many platforms, so it should be easy to install, without needing to compile the underlying Rust code from source.</p>"},{"location":"api/functions/","title":"Functions","text":""},{"location":"api/functions/#geopolars.from_arrow","title":"geopolars.from_arrow","text":"<pre><code>geopolars.from_arrow(\n    a: pa.Table | pa.Array | pa.ChunkedArray,\n) -&gt; GeoDataFrame | GeoSeries\n</code></pre> <p>Construct a GeoPolars <code>GeoDataFrame</code> or <code>GeoSeries</code> from an Arrow Table or Array.</p> <p>This operation will be zero copy for the most part. Types that are not supported by Polars may be cast to the closest supported type.</p> <p>Parameters:</p> <ul> <li> a             (<code>pa.Table | pa.Array | pa.ChunkedArray</code>)         \u2013          <p>Data represented as Arrow Table or Array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoDataFrame | GeoSeries</code>         \u2013          <p><code>GeoDataFrame</code> or <code>GeoSeries</code></p> </li> </ul>"},{"location":"api/functions/#geopolars.from_geopandas","title":"geopolars.from_geopandas","text":"<pre><code>geopolars.from_geopandas(\n    gdf: geopandas.GeoDataFrame\n    | geopandas.GeoSeries\n    | pandas.DataFrame\n    | pandas.Series,\n    force_wkb: bool = True,\n) -&gt; GeoDataFrame | GeoSeries | DataFrame | Series\n</code></pre> <p>Construct a GeoPolars <code>GeoDataFrame</code> or <code>GeoSeries</code> from a <code>geopandas.GeoDataFrame</code> or <code>geopandas.GeoSeries</code>.</p> <p>This operation clones data.</p> <p>This requires that <code>geopandas</code> and <code>pyarrow</code> are installed.</p> <p>Parameters:</p> <ul> <li> gdf             (<code>geopandas.GeoDataFrame | geopandas.GeoSeries | pandas.DataFrame | pandas.Series</code>)         \u2013          <p>Input data to convert from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoDataFrame | GeoSeries | DataFrame | Series</code>         \u2013          <p>A GeoPolars <code>GeoDataFrame</code> or <code>GeoSeries</code></p> </li> </ul>"},{"location":"api/geodataframe/","title":"GeoDataFrame","text":""},{"location":"api/geodataframe/#constructor","title":"Constructor","text":""},{"location":"api/geodataframe/#geopolars.GeoDataFrame","title":"geopolars.GeoDataFrame","text":"<p>         Bases: <code>pl.DataFrame</code></p>"},{"location":"api/geodataframe/#geopolars.internals.geodataframe.GeoDataFrame.get_column","title":"get_column","text":"<pre><code>get_column(name: str) -&gt; pl.Series | GeoSeries\n</code></pre> <p>Get a single column as Series or GeoSeries by name.</p> <p>Return GeoSeries if requested column is geometry column.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>Name of the column to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pl.Series | GeoSeries</code>         \u2013          <p>A column of the DataFrame as either a polars <code>Series</code> or a <code>GeoSeries</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"foo\": [1, 2, 3], \"bar\": [4, 5, 6]})\n&gt;&gt;&gt; df.get_column(\"foo\")\nshape: (3,)\nSeries: 'foo' [i64]\n[\n        1\n        2\n        3\n]\n</code></pre>"},{"location":"api/geoseries/","title":"GeoSeries","text":""},{"location":"api/geoseries/#constructor","title":"Constructor","text":""},{"location":"api/geoseries/#geopolars.GeoSeries","title":"geopolars.GeoSeries","text":"<p>         Bases: <code>pl.Series</code></p> <p>Extension of <code>polars.Series</code> to handle geospatial vector data.</p>"},{"location":"api/geoseries/#geopolars.internals.geoseries.GeoSeries.to_crs","title":"to_crs","text":"<pre><code>to_crs(\n    from_crs: str | pyproj.crs.CRS,\n    to_crs: str | pyproj.crs.CRS,\n) -&gt; GeoSeries\n</code></pre> <p>Transform all geometries in a GeoSeries to a different coordinate reference system.</p> <p>For now, you must pass in both <code>from_crs</code> and <code>to_crs</code>. In the future, we'll handle the current CRS automatically.</p> <p>This method will transform all points in all objects.  It has no notion of projecting entire geometries.  All segments joining points are assumed to be lines in the current projection, not geodesics.  Objects crossing the dateline (or other projection boundary) will have undesirable behavior.</p> <p>Parameters:</p> <ul> <li> from_crs             (<code>str | pyproj.crs.CRS</code>)         \u2013          <p>Origin coordinate system. The value can be anything accepted by <code>pyproj.CRS.from_user_input()</code>, such as an authority string (eg \"EPSG:4326\") or a WKT string.</p> </li> <li> to_crs             (<code>str | pyproj.crs.CRS</code>)         \u2013          <p>Destination coordinate system. The value can be anything accepted by <code>pyproj.CRS.from_user_input()</code>, such as an authority string (eg \"EPSG:4326\") or a WKT string.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoSeries</code>         \u2013          <p>A <code>GeoSeries</code> with all geometries transformed to a new coordinate reference system.</p> </li> </ul>"},{"location":"api/geoseries/#geopolars.internals.geoseries.GeoSeries.to_geopandas","title":"to_geopandas","text":"<pre><code>to_geopandas() -&gt; geopandas.GeoSeries\n</code></pre> <p>Converts this <code>GeoSeries</code> to a <code>geopandas.GeoSeries</code>.</p> <p>This operation clones data. This requires that <code>geopandas</code> and <code>pyarrow</code> are installed.</p> <p>Returns:</p> <ul> <li> <code>geopandas.GeoSeries</code>         \u2013          <p>This <code>GeoSeries</code> as a <code>geopandas.GeoSeries</code>.</p> </li> </ul>"},{"location":"api/geoseries/#general-methods-and-attributes","title":"General methods and attributes","text":""},{"location":"api/geoseries/#geopolars.internals.geoseries.GeoSeries.geo","title":"geopolars.internals.geoseries.GeoSeries.geo  <code>property</code>","text":"<pre><code>geopolars.internals.geoseries.GeoSeries.geo: GeoRustSeries\n</code></pre>"},{"location":"api/io/","title":"Input/Output","text":""},{"location":"api/io/#gis-vector-files","title":"GIS vector files","text":""},{"location":"api/io/#geopolars.read_file","title":"geopolars.read_file","text":"<pre><code>geopolars.read_file(\n    path_or_buffer: Path | str | bytes,\n    /,\n    layer: int | str | None = None,\n    encoding: str | None = None,\n    columns: str | None = None,\n    read_geometry: bool = True,\n    force_2d: bool = False,\n    skip_features: int = 0,\n    max_features: int | None = None,\n    where: str | None = None,\n    bbox: tuple[float, float, float, float] | None = None,\n    fids: tuple[float, float, float, float] | None = None,\n    sql: tuple[float, float, float, float] | None = None,\n    sql_dialect: tuple[float, float, float, float]\n    | None = None,\n    return_fids: tuple[float, float, float, float]\n    | None = False,\n) -&gt; DataFrame | GeoDataFrame\n</code></pre> <p>Read OGR data source into numpy arrays.</p> <p>IMPORTANT: non-linear geometry types (e.g., MultiSurface) are converted to their linear approximations.</p> <p>Parameters:</p> <ul> <li> path_or_buffer             (<code>Path | str | bytes</code>)         \u2013          <p>A dataset path or URI, or raw buffer.</p> </li> <li> layer             (<code>int | str | None</code>)         \u2013          <p>If an integer is provided, it corresponds to the index of the layer with the data source.  If a string is provided, it must match the name of the layer in the data source.  Defaults to first layer in data source.</p> </li> <li> encoding             (<code>str | None</code>)         \u2013          <p>If present, will be used as the encoding for reading string values from the data source, unless encoding can be inferred directly from the data source.</p> </li> <li> columns         \u2013          <p>list-like, optional (default: all columns) List of column names to import from the data source.  Column names must exactly match the names in the data source, and will be returned in the order they occur in the data source.  To avoid reading any columns, pass an empty list-like.</p> </li> <li> read_geometry             (<code>bool</code>)         \u2013          <p>If True, will read geometry into WKB. If False, geometry will be None. Defaults to True.</p> </li> <li> force_2d             (<code>bool</code>)         \u2013          <p>If the geometry has Z values, setting this to True will cause those to be ignored and 2D geometries to be returned. Defaults to False.</p> </li> <li> skip_features             (<code>int</code>)         \u2013          <p>Number of features to skip from the beginning of the file before returning features.  Must be less than the total number of features in the file.</p> </li> <li> max_features         \u2013          <p>int, optional (default: None) Number of features to read from the file.  Must be less than the total number of features in the file minus skip_features (if used).</p> </li> <li> where             (<code>str | None</code>)         \u2013          <p>Where clause to filter features in layer by attribute values.  Uses a restricted form of SQL WHERE clause, defined here.</p> <p>Examples:</p> <ul> <li><code>\"ISO_A3 = 'CAN'\"</code></li> <li><code>\"POP_EST &gt; 10000000 AND POP_EST &lt; 100000000\"</code></li> </ul> </li> <li> bbox             (<code>tuple[float, float, float, float] | None</code>)         \u2013          <p>If present, will be used to filter records whose geometry intersects this box.  This must be in the same CRS as the dataset.  If GEOS is present and used by GDAL, only geometries that intersect this bbox will be returned; if GEOS is not available or not used by GDAL, all geometries with bounding boxes that intersect this bbox will be returned.</p> </li> <li> fids         \u2013          <p>array-like, optional (default: None) Array of integer feature id (FID) values to select. Cannot be combined with other keywords to select a subset (<code>skip_features</code>, <code>max_features</code>, <code>where</code> or <code>bbox</code>). Note that the starting index is driver and file specific (e.g. typically 0 for Shapefile and 1 for GeoPackage, but can still depend on the specific file). The performance of reading a large number of features usings FIDs is also driver specific.</p> </li> <li> return_fids         \u2013          <p>bool, optional (default: False) If True, will return the FIDs of the feature that were read.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | GeoDataFrame</code>         \u2013          <p>A GeoPolars GeoDataFrame or Polars DataFrame</p> </li> </ul>"},{"location":"api/operations/series_georust/","title":"GeoRust Series","text":""},{"location":"api/operations/series_georust/#geopolars.GeoRustSeries","title":"geopolars.GeoRustSeries  <code>dataclass</code>","text":"<p>Operations to be done via GeoRust native algorithms</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.area","title":"area  <code>property</code>","text":"<pre><code>area: pl.Series\n</code></pre> <p>Returns a <code>Series</code> containing the area of each geometry in the <code>GeoSeries</code> expressed in the units of the CRS.</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.area--see-also","title":"See also","text":"<ul> <li><code>euclidean_length</code>: measure   euclidean length</li> <li><code>geodesic_length</code>: measure geodesic   length</li> </ul>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.area--notes","title":"Notes","text":"<p>Area may be invalid for a geographic CRS using degrees as units; use <code>to_crs</code> to project geometries to a planar CRS before using this function.</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.centroid","title":"centroid  <code>property</code>","text":"<pre><code>centroid: GeoSeries\n</code></pre> <p>Returns a <code>GeoSeries</code> of points representing the centroid of each geometry.</p> <p>Note that centroid does not have to be on or within original geometry.</p> <p>Returns:</p> <ul> <li> <code>GeoSeries</code>         \u2013          <p>New <code>GeoSeries</code> with centroids.</p> </li> </ul>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.geom_type","title":"geom_type  <code>property</code>","text":"<pre><code>geom_type: pl.Series\n</code></pre> <p>Returns a <code>Series</code> of strings specifying the <code>Geometry Type</code> of each object.</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.x","title":"x  <code>property</code>","text":"<pre><code>x: pl.Series\n</code></pre> <p>Return the x location of point geometries in a GeoSeries</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.x--see-also","title":"See Also","text":"<p><code>y</code></p> <p>Returns:</p> <ul> <li> <code>pl.Series</code>         \u2013          <p>Series with x values</p> </li> </ul>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.y","title":"y  <code>property</code>","text":"<pre><code>y: pl.Series\n</code></pre> <p>Return the y location of point geometries in a GeoSeries</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.y--see-also","title":"See Also","text":"<p><code>x</code></p> <p>Returns:</p> <ul> <li> <code>pl.Series</code>         \u2013          <p>Series with y values</p> </li> </ul>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.affine_transform","title":"affine_transform","text":"<pre><code>affine_transform(\n    matrix: list[float] | AffineTransform,\n) -&gt; GeoSeries\n</code></pre> <p>Returns a <code>GeoSeries</code> with translated geometries.</p> <p>See Shapely's <code>affine_transform</code> or Rust's <code>AffineOps</code> for details.</p> <p>Parameters:</p> <ul> <li> matrix             (<code>list[float] | AffineTransform</code>)         \u2013          <p>The 6 parameter matrix is <code>[a, b, d, e, xoff, yoff]</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoSeries</code>         \u2013          <p>New <code>GeoSeries</code> with translated geometries.</p> </li> </ul>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.convex_hull","title":"convex_hull","text":"<pre><code>convex_hull() -&gt; GeoSeries\n</code></pre> <p>Returns a <code>GeoSeries</code> of geometries representing the convex hull of each geometry.</p> <p>The convex hull of a geometry is the smallest convex <code>Polygon</code> containing all the points in each geometry, unless the number of points in the geometric object is less than three. For two points, the convex hull collapses to a <code>LineString</code>; for 1, a <code>Point</code>.</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.convex_hull--see-also","title":"See also","text":"<ul> <li><code>envelope</code>: bounding rectangle geometry</li> </ul>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.distance","title":"distance","text":"<pre><code>distance(other: GeoSeries) -&gt; GeoSeries\n</code></pre> <p>Returns a Series containing the distance to aligned other.</p> <p>Distance is cartesian distance in 2D space, and the units of the output are in terms of the CRS of the two input series. The operation works on a 1-to-1 row-wise manner.</p> <p>Parameters:</p> <ul> <li> other             (<code>GeoSeries</code>)         \u2013          <p>The series to which calculate distance in 1-to-1 row-wise manner.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoSeries</code>         \u2013          <p>GeoSeries containing the distance from each element to the element in</p> </li> <li> <code>GeoSeries</code>         \u2013          <p><code>other</code>.</p> </li> </ul>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.envelope","title":"envelope","text":"<pre><code>envelope() -&gt; GeoSeries\n</code></pre> <p>Returns a <code>GeoSeries</code> of geometries representing the envelope of each geometry.</p> <p>The envelope of a geometry is the bounding rectangle. That is, the point or smallest rectangular polygon (with sides parallel to the coordinate axes) that contains the geometry.</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.envelope--see-also","title":"See also","text":"<p><code>convex_hull</code>: convex hull geometry</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.euclidean_length","title":"euclidean_length","text":"<pre><code>euclidean_length() -&gt; pl.Series\n</code></pre> <p>Returns a <code>Series</code> containing the euclidean length of each geometry expressed in the units of the CRS.</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.euclidean_length--see-also","title":"See also","text":"<p><code>area</code>: measure area of a polygon</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.euclidean_length--notes","title":"Notes","text":"<p>Length may be invalid for a geographic CRS using degrees as units; use <code>GeoSeries.to_crs</code> to project geometries to a planar CRS before using this function.</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.exterior","title":"exterior","text":"<pre><code>exterior() -&gt; GeoSeries\n</code></pre> <p>Returns a <code>GeoSeries</code> of LinearRings representing the outer boundary of each polygon in the GeoSeries.</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.geodesic_length","title":"geodesic_length","text":"<pre><code>geodesic_length(\n    method: GeodesicMethod = \"geodesic\",\n) -&gt; polars.Series\n</code></pre> <p>Returns a <code>Series</code> containing the geodesic length of each geometry expressed in meters.</p> <p>Parameters:</p> <ul> <li> method             (<code>GeodesicMethod</code>)         \u2013          <p>Method for calculating length: one of <code>'geodesic'</code>, <code>'haversine'</code>, or <code>'vincenty'</code>.</p> <p><code>'geodesic'</code> uses the geodesic measurement methods given by <code>Karney (2013)</code>. As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges. <code>'vincenty'</code> uses <code>Vincenty's formulae</code>. <code>'haversine'</code> uses the <code>haversine formula</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>polars.Series</code>         \u2013          <p><code>Series</code> containing the geodesic length of each geometry</p> </li> </ul> <p>expressed in meters.</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.geodesic_length--see-also","title":"See also","text":"<p><code>area</code>: measure area of a polygon</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.geodesic_length--notes","title":"Notes","text":"<p>This method is only meaningful for input data as longitude/latitude coordinates on the WGS84 ellipsoid (i.e. EPSG:4326).</p> <p>Length may be invalid for a geographic CRS using degrees as units; use <code>GeoSeries.to_crs</code> to project geometries to a planar CRS before using this function.</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; pl.Series\n</code></pre> <p>Returns a <code>Series</code> of <code>dtype('bool')</code> with value <code>True</code> for empty geometries.</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.is_ring","title":"is_ring","text":"<pre><code>is_ring() -&gt; pl.Series\n</code></pre> <p>Returns a <code>Series</code> of <code>dtype('bool')</code> with value <code>True</code> for features that are closed.</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.rotate","title":"rotate","text":"<pre><code>rotate(\n    angle: float, origin: TransformOrigin = \"center\"\n) -&gt; GeoSeries\n</code></pre> <p>Returns a <code>GeoSeries</code> with rotated geometries.</p> <p>See Shapely's <code>rotate</code> or Rust's <code>Rotate</code> for details.</p> <p>Parameters:</p> <ul> <li> angle             (<code>float</code>)         \u2013          <p>float The angle of rotation in degrees. Positive angles are counter-clockwise and negative are clockwise rotations.</p> </li> <li> origin             (<code>TransformOrigin</code>)         \u2013          <p>string or tuple (x, y) The point of origin can be a keyword 'center' for the bounding box center (default), 'centroid' for the geometry's centroid, or a coordinate tuple (x, y).</p> </li> </ul>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.scale","title":"scale","text":"<pre><code>scale(\n    xfact: float = 1.0,\n    yfact: float = 1.0,\n    origin: TransformOrigin = \"center\",\n) -&gt; GeoSeries\n</code></pre> <p>Returns a <code>GeoSeries</code> with scaled geometries.</p> <p>The geometries can be scaled by different factors along each dimension. Negative scale factors will mirror or reflect coordinates.</p> <p>See Shapely's <code>scale</code> or Rust's <code>Scale</code> for details.</p> <p>xfact: Scaling factors for the x dimension. yfact: Scaling factors for the y dimension.</p> The point of origin can be a keyword 'center' for the 2D bounding <p>box center (default), 'centroid' for the geometry's 2D centroid or a coordinate tuple (x, y).</p>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.skew","title":"skew","text":"<pre><code>skew(\n    xs: float = 0.0,\n    ys: float = 0.0,\n    origin: TransformOrigin = \"center\",\n) -&gt; GeoSeries\n</code></pre> <p>Returns a <code>GeoSeries</code> with skewed geometries.</p> <p>The geometries are sheared by angles along the x and y dimensions.</p> <p>See Shapely's <code>skew</code> or Rust's <code>Skew</code> for details.</p> <p>xs: The shear angle for the x axis in degrees. ys: The shear angle for the y axis in degrees.</p> The point of origin can be a keyword <code>'center'</code> for the bounding box <p>center (default), <code>'centroid'</code> for the geometry's centroid or a coordinate tuple <code>(x, y)</code>.</p> <p>Returns:</p> <ul> <li> <code>GeoSeries</code>         \u2013          <p><code>GeoSeries</code> with skewed geometries.</p> </li> </ul>"},{"location":"api/operations/series_georust/#geopolars.internals.georust.geoseries.GeoRustSeries.translate","title":"translate","text":"<pre><code>translate(\n    xoff: float = 0.0, yoff: float = 0.0\n) -&gt; GeoSeries\n</code></pre> <p>Returns a <code>GeoSeries</code> with translated geometries.</p> <p>See Shapely's <code>translate</code> or Rust's <code>Translate</code> for details.</p> <p>Parameters:</p> <ul> <li> xoff             (<code>float</code>)         \u2013          <p>Amount of offset along the x dimension.</p> </li> <li> yoff             (<code>float</code>)         \u2013          <p>Amount of offset along the y dimension.</p> </li> </ul>"}]}